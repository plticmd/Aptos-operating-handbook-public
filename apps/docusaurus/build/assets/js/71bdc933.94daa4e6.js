"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[3747],{9303:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>r});var t=s(63159),a=s(83581);const o={},c="Uses and Aliases",l={id:"move/book/uses",title:"Uses and Aliases",description:"The use syntax can be used to create aliases to members in other modules. use can be used to",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/uses.md",sourceDirName:"move/book",slug:"/move/book/uses",permalink:"/move/book/uses",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/uses.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"Abilities(\u6a5f\u80fd)",permalink:"/move/book/abilities"},next:{title:"\u30d5\u30ec\u30f3\u30ba",permalink:"/move/book/friends"}},d={},r=[{value:"Syntax",id:"syntax",level:2},{value:"Inside a <code>module</code>",id:"inside-a-module",level:2},{value:"Inside an expression",id:"inside-an-expression",level:2},{value:"Naming rules",id:"naming-rules",level:2},{value:"Uniqueness",id:"uniqueness",level:2},{value:"Shadowing",id:"shadowing",level:2},{value:"Unused Use or Alias",id:"unused-use-or-alias",level:2}];function i(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"uses-and-aliases",children:"Uses and Aliases"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"use"})," syntax can be used to create aliases to members in other modules. ",(0,t.jsx)(n.code,{children:"use"})," can be used to\ncreate aliases that last either for the entire module, or for a given expression block scope."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsxs)(n.p,{children:["There are several different syntax cases for ",(0,t.jsx)(n.code,{children:"use"}),". Starting with the most simple, we have the\nfollowing for creating aliases to other modules"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>;\nuse <address>::<module name> as <module alias name>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::vector as V;\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"use std::vector;"})," introduces an alias ",(0,t.jsx)(n.code,{children:"vector"})," for ",(0,t.jsx)(n.code,{children:"std::vector"}),". This means that anywhere you\nwould want to use the module name ",(0,t.jsx)(n.code,{children:"std::vector"})," (assuming this ",(0,t.jsx)(n.code,{children:"use"})," is in scope), you could use\n",(0,t.jsx)(n.code,{children:"vector"})," instead. ",(0,t.jsx)(n.code,{children:"use std::vector;"})," is equivalent to ",(0,t.jsx)(n.code,{children:"use std::vector as vector;"})]}),"\n",(0,t.jsxs)(n.p,{children:["Similarly ",(0,t.jsx)(n.code,{children:"use std::vector as V;"})," would let you use ",(0,t.jsx)(n.code,{children:"V"})," instead of ",(0,t.jsx)(n.code,{children:"std::vector"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::vector as V;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = vector::empty();\n    let v3 = V::empty();\n    (v1, v2, v3)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"If you want to import a specific module member (such as a function, struct, or constant). You can\nuse the following syntax."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>::<module member>;\nuse <address>::<module name>::<module member> as <member alias>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::empty;\nuse std::vector::empty as empty_vec;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This would let you use the function ",(0,t.jsx)(n.code,{children:"std::vector::empty"})," without full qualification. Instead, you\ncould use ",(0,t.jsx)(n.code,{children:"empty"})," and ",(0,t.jsx)(n.code,{children:"empty_vec"})," respectively. Again, ",(0,t.jsx)(n.code,{children:"use std::vector::empty;"})," is equivalent to\n",(0,t.jsx)(n.code,{children:"use std::vector::empty as empty;"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::empty;\nuse std::vector::empty as empty_vec;\n\nfun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n    let v1 = std::vector::empty();\n    let v2 = empty();\n    let v3 = empty_vec();\n    (v1, v2, v3)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"If you want to add aliases for multiple module members at once, you can do so with the following\nsyntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>::{<module member>, <module member> as <member alias> ... };\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::{push_back, length as len, pop_back};\n\nfun swap_last_two<T>(v: &mut vector<T>) {\n    assert!(len(v) >= 2, 42);\n    let last = pop_back(v);\n    let second_to_last = pop_back(v);\n    push_back(v, last);\n    push_back(v, second_to_last)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you need to add an alias to the Module itself in addition to module members, you can do that in a\nsingle ",(0,t.jsx)(n.code,{children:"use"})," using ",(0,t.jsx)(n.code,{children:"Self"}),". ",(0,t.jsx)(n.code,{children:"Self"})," is a member of sorts that refers to the module."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::{Self, empty};\n"})}),"\n",(0,t.jsx)(n.p,{children:"For clarity, all the following are equivalent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::vector as vector;\nuse std::vector::Self;\nuse std::vector::Self as vector;\nuse std::vector::{Self};\nuse std::vector::{Self as vector};\n"})}),"\n",(0,t.jsx)(n.p,{children:"If needed, you can have as many aliases for any item as you like"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::{\n    Self,\n    Self as V,\n    length,\n    length as len,\n};\n\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    // all options available given the `use` above\n    assert!(vector::length(v) > 1, 42);\n    assert!(V::length(v) > 1, 42);\n    assert!(length(v) > 1, 42);\n    assert!(len(v) > 1, 42);\n\n    (vector::pop_back(v), vector::pop_back(v))\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"inside-a-module",children:["Inside a ",(0,t.jsx)(n.code,{children:"module"})]}),"\n",(0,t.jsxs)(n.p,{children:["Inside a ",(0,t.jsx)(n.code,{children:"module"})," all ",(0,t.jsx)(n.code,{children:"use"})," declarations are usable regardless of the order of declaration."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n    use std::vector;\n\n    fun example(): vector<u8> {\n        let v = empty();\n        vector::push_back(&mut v, 0);\n        vector::push_back(&mut v, 10);\n        v\n    }\n\n    use std::vector::empty;\n}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The aliases declared by ",(0,t.jsx)(n.code,{children:"use"})," in the module usable within that module."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, the aliases introduced cannot conflict with other module members. See\n",(0,t.jsx)(n.a,{href:"#uniqueness",children:"Uniqueness"})," for more details"]}),"\n",(0,t.jsx)(n.h2,{id:"inside-an-expression",children:"Inside an expression"}),"\n",(0,t.jsxs)(n.p,{children:["You can add ",(0,t.jsx)(n.code,{children:"use"})," declarations to the beginning of any expression block"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        use std::vector::{empty, push_back};\n\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    }\n}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As with ",(0,t.jsx)(n.code,{children:"let"}),", the aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," in an expression block are removed at the end of that\nblock."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n\n    fun example(): vector<u8> {\n        let result = {\n            use std::vector::{empty, push_back};\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 10);\n            v\n        };\n        result\n    }\n\n}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Attempting to use the alias after the block ends will result in an error"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun example(): vector<u8> {\n    let result = {\n        use std::vector::{empty, push_back};\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    };\n    let v2 = empty(); // ERROR!\n//           ^^^^^ unbound function 'empty'\n    result\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Any ",(0,t.jsx)(n.code,{children:"use"})," must be the first item in the block. If the ",(0,t.jsx)(n.code,{children:"use"})," comes after any expression or ",(0,t.jsx)(n.code,{children:"let"}),", it\nwill result in a parsing error"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"{\n    let x = 0;\n    use std::vector; // ERROR!\n    let v = vector::empty();\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"naming-rules",children:"Naming rules"}),"\n",(0,t.jsxs)(n.p,{children:["Aliases must follow the same rules as other module members. This means that aliases to structs or\nconstants must start with ",(0,t.jsx)(n.code,{children:"A"})," to ",(0,t.jsx)(n.code,{children:"Z"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule data {\n    struct S {}\n    const FLAG: bool = false;\n    fun foo() {}\n}\nmodule example {\n    use 0x42::data::{\n        S as s, // ERROR!\n        FLAG as fLAG, // ERROR!\n        foo as FOO,  // valid\n        foo as bar, // valid\n    };\n}\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"uniqueness",children:"Uniqueness"}),"\n",(0,t.jsxs)(n.p,{children:["Inside a given scope, all aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," declarations must be unique."]}),"\n",(0,t.jsxs)(n.p,{children:["For a module, this means aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," cannot overlap"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n\n    use std::vector::{empty as foo, length as foo}; // ERROR!\n    //                                        ^^^ duplicate 'foo'\n\n    use std::vector::empty as bar;\n\n    use std::vector::length as bar; // ERROR!\n    //                         ^^^ duplicate 'bar'\n\n}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"And, they cannot overlap with any of the module's other members"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule data {\n    struct S {}\n}\nmodule example {\n    use 0x42::data::S;\n\n    struct S { value: u64 } // ERROR!\n    //     ^ conflicts with alias 'S' above\n}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Inside an expression block, they cannot overlap with each other, but they can\n",(0,t.jsx)(n.a,{href:"#shadowing",children:"shadow"})," other aliases or names from an outer scope"]}),"\n",(0,t.jsx)(n.h2,{id:"shadowing",children:"Shadowing"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"use"})," aliases inside of an expression block can shadow names (module members or aliases) from the\nouter scope. As with shadowing of locals, the shadowing ends at the end of the expression block;"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n\n    struct WrappedVector { vec: vector<u64> }\n\n    fun empty(): WrappedVector {\n        WrappedVector { vec: std::vector::empty() }\n    }\n\n    fun example1(): (WrappedVector, WrappedVector) {\n        let vec = {\n            use std::vector::{empty, push_back};\n            // 'empty' now refers to std::vector::empty\n\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 1);\n            push_back(&mut v, 10);\n            v\n        };\n        // 'empty' now refers to Self::empty\n\n        (empty(), WrappedVector { vec })\n    }\n\n    fun example2(): (WrappedVector, WrappedVector) {\n        use std::vector::{empty, push_back};\n        let w: WrappedVector = {\n            use 0x42::example::empty;\n            empty()\n        };\n        push_back(&mut w.vec, 0);\n        push_back(&mut w.vec, 1);\n        push_back(&mut w.vec, 10);\n\n        let vec = empty();\n        push_back(&mut vec, 0);\n        push_back(&mut vec, 1);\n        push_back(&mut vec, 10);\n\n        (w, WrappedVector { vec })\n    }\n}\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"unused-use-or-alias",children:"Unused Use or Alias"}),"\n",(0,t.jsxs)(n.p,{children:["An unused ",(0,t.jsx)(n.code,{children:"use"})," will result in an error"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n    use std::vector::{empty, push_back}; // ERROR!\n    //                       ^^^^^^^^^ unused alias 'push_back'\n\n    fun example(): vector<u8> {\n        empty()\n    }\n}\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}},83581:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>l});var t=s(11855);const a={},o=t.createContext(a);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);