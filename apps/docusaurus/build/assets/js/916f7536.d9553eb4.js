"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[7538],{86401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(63159),i=t(83581);const s={},a="Generics",o={id:"move/book/generics",title:"Generics",description:"Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term generics interchangeably with type parameters and type arguments.",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/generics.md",sourceDirName:"move/book",slug:"/move/book/generics",permalink:"/move/book/generics",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/generics.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"\u5b9a\u6570",permalink:"/move/book/constants"},next:{title:"Abilities(\u6a5f\u80fd)",permalink:"/move/book/abilities"}},c={},l=[{value:"Declaring Type Parameters",id:"declaring-type-parameters",level:2},{value:"Generic Functions",id:"generic-functions",level:3},{value:"Generic Structs",id:"generic-structs",level:3},{value:"Type Arguments",id:"type-arguments",level:2},{value:"Calling Generic Functions",id:"calling-generic-functions",level:3},{value:"Using Generic Structs",id:"using-generic-structs",level:3},{value:"Type Argument Mismatch",id:"type-argument-mismatch",level:3},{value:"Type Inference",id:"type-inference",level:2},{value:"Unused Type Parameters",id:"unused-type-parameters",level:2},{value:"Phantom Type Parameters",id:"phantom-type-parameters",level:3},{value:"Declaration",id:"declaration",level:4},{value:"Instantiation",id:"instantiation",level:4},{value:"Phantom Type Parameters with Ability Constraints",id:"phantom-type-parameters-with-ability-constraints",level:4},{value:"Constraints",id:"constraints",level:2},{value:"Declaring Constraints",id:"declaring-constraints",level:3},{value:"Verifying Constraints",id:"verifying-constraints",level:3},{value:"Limitations on Recursions",id:"limitations-on-recursions",level:2},{value:"Recursive Structs",id:"recursive-structs",level:3},{value:"Advanced Topic: Type-level Recursions",id:"advanced-topic-type-level-recursions",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"generics",children:"Generics"}),"\n",(0,r.jsxs)(n.p,{children:["Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as ",(0,r.jsx)(n.em,{children:"parametric polymorphism"}),". In Move, we will often use the term generics interchangeably with type parameters and type arguments."]}),"\n",(0,r.jsx)(n.p,{children:"Generics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation."}),"\n",(0,r.jsx)(n.h2,{id:"declaring-type-parameters",children:"Declaring Type Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["Both functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets ",(0,r.jsx)(n.code,{children:"<...>"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,r.jsx)(n.p,{children:"Type parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun id<T>(x: T): T {\n    // this type annotation is unnecessary but valid\n    (x: T)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once defined, the type parameter ",(0,r.jsx)(n.code,{children:"T"})," can be used in parameter types, return types, and inside the function body."]}),"\n",(0,r.jsx)(n.h3,{id:"generic-structs",children:"Generic Structs"}),"\n",(0,r.jsx)(n.p,{children:"Type parameters for structs are placed after the struct name, and can be used to name the types of the fields."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct Foo<T> has copy, drop { x: T }\n\nstruct Bar<T1, T2> has copy, drop {\n    x: T1,\n    y: vector<T2>,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.a,{href:"#unused-type-parameters",children:"type parameters do not have to be used"})]}),"\n",(0,r.jsx)(n.h2,{id:"type-arguments",children:"Type Arguments"}),"\n",(0,r.jsx)(n.h3,{id:"calling-generic-functions",children:"Calling Generic Functions"}),"\n",(0,r.jsx)(n.p,{children:"When calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id<bool>(true);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you do not specify the type arguments, Move's ",(0,r.jsx)(n.a,{href:"#type-inference",children:"type inference"})," will supply them for you."]}),"\n",(0,r.jsx)(n.h3,{id:"using-generic-structs",children:"Using Generic Structs"}),"\n",(0,r.jsx)(n.p,{children:"Similarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let foo = Foo<bool> { x: true };\n    let Foo<bool> { x } = foo;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you do not specify the type arguments, Move's ",(0,r.jsx)(n.a,{href:"#type-inference",children:"type inference"})," will supply them for you."]}),"\n",(0,r.jsx)(n.h3,{id:"type-argument-mismatch",children:"Type Argument Mismatch"}),"\n",(0,r.jsx)(n.p,{children:"If you specify the type arguments, and they conflict with the actual values supplied, an error will be given:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id<u64>(true); // error! true is not a u64\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"and similarly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let foo = Foo<bool> { x: 0 }; // error! 0 is not a bool\n    let Foo<address> { x } = foo; // error! bool is incompatible with address\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-inference",children:"Type Inference"}),"\n",(0,r.jsx)(n.p,{children:"In most cases, the Move compiler will be able to infer the type arguments, so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id(true);\n    //        ^ <bool> is inferred\n\n    let foo = Foo { x: true };\n    //           ^ <bool> is inferred\n\n    let Foo { x } = foo;\n    //     ^ <bool> is inferred\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        // let v = vector::new();\n        //                    ^ The compiler cannot figure out the element type.\n\n        let v = vector::new<u64>();\n        //                 ^~~~~ Must annotate manually.\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, the compiler will be able to infer the type if that return value is used later in that function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    using std::vector;\n\n    fun foo() {\n        let v = vector::new();\n        //                 ^ <u64> is inferred\n        vector::push_back(&mut v, 42);\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unused-type-parameters",children:"Unused Type Parameters"}),"\n",(0,r.jsx)(n.p,{children:"For a struct definition,\nan unused type parameter is one that\ndoes not appear in any field defined in the struct,\nbut is checked statically at compile time.\nMove allows unused type parameters so the following struct definition is valid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct Foo<T> {\n    foo: u64\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This can be convenient when modeling certain concepts. Here is an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    // Currency Specifiers\n    struct Currency1 {}\n    struct Currency2 {}\n\n    // A generic coin type that can be instantiated using a currency\n    // specifier type.\n    //   e.g. Coin<Currency1>, Coin<Currency2> etc.\n    struct Coin<Currency> has store {\n        value: u64\n    }\n\n    // Write code generically about all currencies\n    public fun mint_generic<Currency>(value: u64): Coin<Currency> {\n        Coin { value }\n    }\n\n    // Write code concretely about one currency\n    public fun mint_concrete(value: u64): Coin<Currency1> {\n        Coin { value }\n    }\n}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example,\n",(0,r.jsx)(n.code,{children:"struct Coin<Currency>"})," is generic on the ",(0,r.jsx)(n.code,{children:"Currency"})," type parameter,\nwhich specifies the currency of the coin and\nallows code to be written either\ngenerically on any currency or\nconcretely on a specific currency.\nThis genericity applies even when the ",(0,r.jsx)(n.code,{children:"Currency"})," type parameter\ndoes not appear in any of the fields defined in ",(0,r.jsx)(n.code,{children:"Coin"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"phantom-type-parameters",children:"Phantom Type Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["In the example above,\nalthough ",(0,r.jsx)(n.code,{children:"struct Coin"})," asks for the ",(0,r.jsx)(n.code,{children:"store"})," ability,\nneither ",(0,r.jsx)(n.code,{children:"Coin<Currency1>"})," nor ",(0,r.jsx)(n.code,{children:"Coin<Currency2>"})," will have the ",(0,r.jsx)(n.code,{children:"store"})," ability.\nThis is because of the rules for\n",(0,r.jsx)(n.a,{href:"/move/book/abilities#conditional-abilities-and-generic-types",children:"Conditional Abilities and Generic Types"}),"\nand the fact that ",(0,r.jsx)(n.code,{children:"Currency1"})," and ",(0,r.jsx)(n.code,{children:"Currency2"})," don't have the ",(0,r.jsx)(n.code,{children:"store"})," ability,\ndespite the fact that they are not even used in the body of ",(0,r.jsx)(n.code,{children:"struct Coin"}),".\nThis might cause some unpleasant consequences.\nFor example, we are unable to put ",(0,r.jsx)(n.code,{children:"Coin<Currency1>"})," into a wallet in the global storage."]}),"\n",(0,r.jsxs)(n.p,{children:["One possible solution would be to\nadd spurious ability annotations to ",(0,r.jsx)(n.code,{children:"Currency1"})," and ",(0,r.jsx)(n.code,{children:"Currency2"}),"\n(i.e., ",(0,r.jsx)(n.code,{children:"struct Currency1 has store {}"}),").\nBut, this might lead to bugs or security vulnerabilities\nbecause it weakens the types with unnecessary ability declarations.\nFor example, we would never expect a resource in the global storage to have a field in type ",(0,r.jsx)(n.code,{children:"Currency1"}),",\nbut this would be possible with the spurious ",(0,r.jsx)(n.code,{children:"store"})," ability.\nMoreover, the spurious annotations would be infectious,\nrequiring many functions generic on the unused type parameter to also include the necessary constraints."]}),"\n",(0,r.jsxs)(n.p,{children:["Phantom type parameters solve this problem.\nUnused type parameters can be marked as ",(0,r.jsx)(n.em,{children:"phantom"})," type parameters,\nwhich do not participate in the ability derivation for structs.\nIn this way,\narguments to phantom type parameters are not considered when deriving the abilities for generic types,\nthus avoiding the need for spurious ability annotations.\nFor this relaxed rule to be sound,\nMove's type system guarantees that a parameter declared as ",(0,r.jsx)(n.code,{children:"phantom"})," is either\nnot used at all in the struct definition, or\nit is only used as an argument to type parameters also declared as ",(0,r.jsx)(n.code,{children:"phantom"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"declaration",children:"Declaration"}),"\n",(0,r.jsxs)(n.p,{children:["In a struct definition\na type parameter can be declared as phantom by adding the ",(0,r.jsx)(n.code,{children:"phantom"})," keyword before its declaration.\nIf a type parameter is declared as phantom we say it is a phantom type parameter.\nWhen defining a struct, Move's type checker ensures that every phantom type parameter is either\nnot used inside the struct definition or\nit is only used as an argument to a phantom type parameter."]}),"\n",(0,r.jsxs)(n.p,{children:["More formally,\nif a type is used as an argument to a phantom type parameter\nwe say the type appears in ",(0,r.jsx)(n.em,{children:"phantom position"}),".\nWith this definition in place,\nthe rule for the correct use of phantom parameters can be specified as follows:\n",(0,r.jsx)(n.strong,{children:"A phantom type parameter can only appear in phantom position"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The following two examples show valid uses of phantom parameters.\nIn the first one,\nthe parameter ",(0,r.jsx)(n.code,{children:"T1"})," is not used at all inside the struct definition.\nIn the second one, the parameter ",(0,r.jsx)(n.code,{children:"T1"})," is only used as an argument to a phantom type parameter."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct S1<phantom T1, T2> { f: u64 }\n                  ^^\n                  Ok: T1 does not appear inside the struct definition\n\n\nstruct S2<phantom T1, T2> { f: S1<T1, T2> }\n                                  ^^\n                                  Ok: T1 appears in phantom position\n"})}),"\n",(0,r.jsx)(n.p,{children:"The following code shows examples of violations of the rule:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct S1<phantom T> { f: T }\n                          ^\n                          Error: Not a phantom position\n\nstruct S2<T> { f: T }\n\nstruct S3<phantom T> { f: S2<T> }\n                             ^\n                             Error: Not a phantom position\n"})}),"\n",(0,r.jsx)(n.h4,{id:"instantiation",children:"Instantiation"}),"\n",(0,r.jsx)(n.p,{children:"When instantiating a struct,\nthe arguments to phantom parameters are excluded when deriving the struct abilities.\nFor example, consider the following code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct S<T1, phantom T2> has copy { f: T1 }\nstruct NoCopy {}\nstruct HasCopy has copy {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Consider now the type ",(0,r.jsx)(n.code,{children:"S<HasCopy, NoCopy>"}),".\nSince ",(0,r.jsx)(n.code,{children:"S"})," is defined with ",(0,r.jsx)(n.code,{children:"copy"})," and all non-phantom arguments have ",(0,r.jsx)(n.code,{children:"copy"}),"\nthen ",(0,r.jsx)(n.code,{children:"S<HasCopy, NoCopy>"})," also has ",(0,r.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"phantom-type-parameters-with-ability-constraints",children:"Phantom Type Parameters with Ability Constraints"}),"\n",(0,r.jsx)(n.p,{children:"Ability constraints and phantom type parameters are orthogonal features in the sense that\nphantom parameters can be declared with ability constraints.\nWhen instantiating a phantom type parameter with an ability constraint,\nthe type argument has to satisfy that constraint,\neven though the parameter is phantom.\nFor example, the following definition is perfectly valid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct S<phantom T: copy> {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The usual restrictions apply and ",(0,r.jsx)(n.code,{children:"T"})," can only be instantiated with arguments having ",(0,r.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"constraints",children:"Constraints"}),"\n",(0,r.jsxs)(n.p,{children:['In the examples above, we have demonstrated how one can use type parameters to define "unknown" types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no ',(0,r.jsx)(n.a,{href:"/move/book/abilities",children:"abilities"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe."}),"\n",(0,r.jsx)(n.h3,{id:"declaring-constraints",children:"Declaring Constraints"}),"\n",(0,r.jsx)(n.p,{children:"Constraints can be imposed on type parameters using the following syntax."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"// T is the name of the type parameter\nT: <ability> (+ <ability>)*\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"<ability>"})," can be any of the four ",(0,r.jsx)(n.a,{href:"/move/book/abilities",children:"abilities"}),", and a type parameter can be constrained with multiple abilities at once. So all the following would be valid type parameter declarations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"T: copy\nT: copy + drop\nT: copy + drop + store + key\n"})}),"\n",(0,r.jsx)(n.h3,{id:"verifying-constraints",children:"Verifying Constraints"}),"\n",(0,r.jsx)(n.p,{children:"Constraints are checked at call sites so the following code won't compile."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct Foo<T: key> { x: T }\n\nstruct Bar { x: Foo<u8> }\n//                  ^ error! u8 does not have 'key'\n\nstruct Baz<T> { x: Foo<T> }\n//                     ^ error! T does not have 'key'\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct R {}\n\nfun unsafe_consume<T>(x: T) {\n    // error! x does not have 'drop'\n}\n\nfun consume<T: drop>(x: T) {\n    // valid!\n    // x will be dropped automatically\n}\n\nfun foo() {\n    let r = R {};\n    consume<R>(r);\n    //      ^ error! R does not have 'drop'\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct R {}\n\nfun unsafe_double<T>(x: T) {\n    (copy x, x)\n    // error! x does not have 'copy'\n}\n\nfun double<T: copy>(x: T) {\n    (copy x, x) // valid!\n}\n\nfun foo(): (R, R) {\n    let r = R {};\n    double<R>(r)\n    //     ^ error! R does not have 'copy'\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For more information, see the abilities section on ",(0,r.jsx)(n.a,{href:"/move/book/abilities#conditional-abilities-and-generic-types",children:"conditional abilities and generic types"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"limitations-on-recursions",children:"Limitations on Recursions"}),"\n",(0,r.jsx)(n.h3,{id:"recursive-structs",children:"Recursive Structs"}),"\n",(0,r.jsx)(n.p,{children:"Generic structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All the following struct definitions are invalid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"struct Foo<T> {\n    x: Foo<u64> // error! 'Foo' containing 'Foo'\n}\n\nstruct Bar<T> {\n    x: Bar<T> // error! 'Bar' containing 'Bar'\n}\n\n// error! 'A' and 'B' forming a cycle, which is not allowed either.\nstruct A<T> {\n    x: B<T, u64>\n}\n\nstruct B<T1, T2> {\n    x: A<T1>\n    y: A<T2>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-topic-type-level-recursions",children:"Advanced Topic: Type-level Recursions"}),"\n",(0,r.jsx)(n.p,{children:"Move allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden."}),"\n",(0,r.jsx)(n.p,{children:"Allowed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<T> -> foo<T> -> ... is valid\n    fun foo<T>() {\n        foo<T>();\n    }\n\n    // Finitely many types -- allowed.\n    // foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid\n    fun foo<T>() {\n        foo<A<u64>>();\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Not allowed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...\n    fun foo<T>() {\n        foo<A<T>>();\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule n {\n    struct A<T> {}\n\n    // Infinitely many types -- NOT allowed.\n    // error!\n    // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>\n    //   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>\n    //   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>\n    //   -> ...\n    fun foo<T1, T2>() {\n        bar<T2, T1>();\n    }\n\n    fun bar<T1, T2> {\n        foo<T1, A<T2>>();\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"address 0x2 {\nmodule m {\n    struct A<T> {}\n\n    fun foo<T>(n: u64) {\n        if (n > 0) {\n            foo<A<T>>(n - 1);\n        };\n    }\n}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},83581:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(11855);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);