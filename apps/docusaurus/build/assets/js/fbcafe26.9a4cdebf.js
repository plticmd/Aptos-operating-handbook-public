"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[3108],{72142:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var l=s(63159),a=s(83581);const i={},t="Local Variables and Scope",r={id:"move/book/variables",title:"Local Variables and Scope",description:"Local variables in Move are lexically (statically) scoped. New variables are introduced with the",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/variables.md",sourceDirName:"move/book",slug:"/move/book/variables",permalink:"/move/book/variables",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/variables.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"Tuples and Unit",permalink:"/move/book/tuples"},next:{title:"\u7b49\u4fa1",permalink:"/move/book/equality"}},o={},c=[{value:"Declaring Local Variables",id:"declaring-local-variables",level:2},{value:"<code>let</code> bindings",id:"let-bindings",level:3},{value:"Variables must be assigned before use",id:"variables-must-be-assigned-before-use",level:3},{value:"Valid variable names",id:"valid-variable-names",level:3},{value:"Type annotations",id:"type-annotations",level:3},{value:"When annotations are necessary",id:"when-annotations-are-necessary",level:3},{value:"Multiple declarations with tuples",id:"multiple-declarations-with-tuples",level:3},{value:"Multiple declarations with structs",id:"multiple-declarations-with-structs",level:3},{value:"Destructuring against references",id:"destructuring-against-references",level:3},{value:"Ignoring Values",id:"ignoring-values",level:3},{value:"General <code>let</code> grammar",id:"general-let-grammar",level:3},{value:"Mutations",id:"mutations",level:2},{value:"Assignments",id:"assignments",level:3},{value:"Mutating through a reference",id:"mutating-through-a-reference",level:3},{value:"Scopes",id:"scopes",level:2},{value:"Expression Blocks",id:"expression-blocks",level:3},{value:"Shadowing",id:"shadowing",level:3},{value:"Move and Copy",id:"move-and-copy",level:2},{value:"Safety",id:"safety",level:3},{value:"Inference",id:"inference",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h1,{id:"local-variables-and-scope",children:"Local Variables and Scope"}),"\n",(0,l.jsxs)(n.p,{children:["Local variables in Move are lexically (statically) scoped. New variables are introduced with the\nkeyword ",(0,l.jsx)(n.code,{children:"let"}),", which will shadow any previous local with the same name. Locals are mutable and can\nbe updated both directly and via a mutable reference."]}),"\n",(0,l.jsx)(n.h2,{id:"declaring-local-variables",children:"Declaring Local Variables"}),"\n",(0,l.jsxs)(n.h3,{id:"let-bindings",children:[(0,l.jsx)(n.code,{children:"let"})," bindings"]}),"\n",(0,l.jsxs)(n.p,{children:["Move programs use ",(0,l.jsx)(n.code,{children:"let"})," to bind variable names to values:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 1;\nlet y = x + x:\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"let"})," can also be used without binding a value to the local."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\n"})}),"\n",(0,l.jsx)(n.p,{children:"The local can then be assigned a value later."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nif (cond) {\n  x = 1\n} else {\n  x = 0\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"This can be very helpful when trying to extract a value from a loop when a default value cannot be\nprovided."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nlet cond = true;\nlet i = 0;\nloop {\n    (x, cond) = foo(i);\n    if (!cond) break;\n    i = i + 1;\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"variables-must-be-assigned-before-use",children:"Variables must be assigned before use"}),"\n",(0,l.jsx)(n.p,{children:"Move's type system prevents a local variable from being used before it has been assigned."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nx + x // ERROR!\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nif (cond) x = 0;\nx + x // ERROR!\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nwhile (cond) x = 0;\nx + x // ERROR!\n"})}),"\n",(0,l.jsx)(n.h3,{id:"valid-variable-names",children:"Valid variable names"}),"\n",(0,l.jsxs)(n.p,{children:["Variable names can contain underscores ",(0,l.jsx)(n.code,{children:"_"}),", letters ",(0,l.jsx)(n.code,{children:"a"})," to ",(0,l.jsx)(n.code,{children:"z"}),", letters ",(0,l.jsx)(n.code,{children:"A"})," to ",(0,l.jsx)(n.code,{children:"Z"}),", and digits ",(0,l.jsx)(n.code,{children:"0"}),"\nto ",(0,l.jsx)(n.code,{children:"9"}),". Variable names must start with either an underscore ",(0,l.jsx)(n.code,{children:"_"})," or a letter ",(0,l.jsx)(n.code,{children:"a"})," through ",(0,l.jsx)(n.code,{children:"z"}),". They\n",(0,l.jsx)(n.em,{children:"cannot"})," start with uppercase letters."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"// all valid\nlet x = e;\nlet _x = e;\nlet _A = e;\nlet x0 = e;\nlet xA = e;\nlet foobar_123 = e;\n\n// all invalid\nlet X = e; // ERROR!\nlet Foo = e; // ERROR!\n"})}),"\n",(0,l.jsx)(n.h3,{id:"type-annotations",children:"Type annotations"}),"\n",(0,l.jsx)(n.p,{children:"The type of local variable can almost always be inferred by Move's type system. However, Move\nallows explicit type annotations that can be useful for readability, clarity, or debuggability. The\nsyntax for adding a type annotation is:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'let x: T = e; // "Variable x of type T is initialized to expression e"\n'})}),"\n",(0,l.jsx)(n.p,{children:"Some examples of explicit type annotations:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'address 0x42 {\nmodule example {\n\n    struct S { f: u64, g: u64 }\n\n    fun annotated() {\n        let u: u8 = 0;\n        let b: vector<u8> = b"hello";\n        let a: address = @0x0;\n        let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n        let S { f, g: f2 }: S = S { f: 0, g: 1 };\n    }\n}\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Note that the type annotations must always be to the right of the pattern:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let (x: &u64, y: &mut u64) = (&0, &mut 1); // ERROR! should be let (x, y): ... =\n"})}),"\n",(0,l.jsx)(n.h3,{id:"when-annotations-are-necessary",children:"When annotations are necessary"}),"\n",(0,l.jsx)(n.p,{children:"In some cases, a local type annotation is required if the type system cannot infer the type. This\ncommonly occurs when the type argument for a generic type cannot be inferred. For example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let _v1 = vector::empty(); // ERROR!\n//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\nlet v2: vector<u64> = vector::empty(); // no error\n"})}),"\n",(0,l.jsxs)(n.p,{children:["In a rarer case, the type system might not be able to infer a type for divergent code (where all the\nfollowing code is unreachable). Both ",(0,l.jsx)(n.code,{children:"return"})," and ",(0,l.jsx)(n.a,{href:"/move/book/abort-and-assert",children:(0,l.jsx)(n.code,{children:"abort"})})," are expressions\nand can have any type. A ",(0,l.jsx)(n.a,{href:"/move/book/loops",children:(0,l.jsx)(n.code,{children:"loop"})})," has type ",(0,l.jsx)(n.code,{children:"()"})," if it has a ",(0,l.jsx)(n.code,{children:"break"}),", but if there is no\nbreak out of the ",(0,l.jsx)(n.code,{children:"loop"}),", it could have any type. If these types cannot be inferred, a type\nannotation is required. For example, this code:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let a: u8 = return ();\nlet b: bool = abort 0;\nlet c: signer = loop ();\n\nlet x = return (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet y = abort 0; // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet z = loop (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\n"})}),"\n",(0,l.jsx)(n.p,{children:"Adding type annotations to this code will expose other errors about dead code or unused local\nvariables, but the example is still helpful for understanding this problem."}),"\n",(0,l.jsx)(n.h3,{id:"multiple-declarations-with-tuples",children:"Multiple declarations with tuples"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"let"})," can introduce more than one local at a time using tuples. The locals declared inside the\nparenthesis are initialized to the corresponding values from the tuple."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let () = ();\nlet (x0, x1) = (0, 1);\nlet (y0, y1, y2) = (0, 1, 2);\nlet (z0, z1, z2, z3) = (0, 1, 2, 3);\n"})}),"\n",(0,l.jsx)(n.p,{children:"The type of the expression must match the arity of the tuple pattern exactly."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let (x, y) = (0, 1, 2); // ERROR!\nlet (x, y, z, q) = (0, 1, 2); // ERROR!\n"})}),"\n",(0,l.jsxs)(n.p,{children:["You cannot declare more than one local with the same name in a single ",(0,l.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let (x, x) = 0; // ERROR!\n"})}),"\n",(0,l.jsx)(n.h3,{id:"multiple-declarations-with-structs",children:"Multiple declarations with structs"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"let"})," can also introduce more than one local at a time when destructuring (or matching against) a\nstruct. In this form, the ",(0,l.jsx)(n.code,{children:"let"})," creates a set of local variables that are initialized to the values\nof the fields from a struct. The syntax looks like this:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"struct T { f1: u64, f2: u64 }\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n"})}),"\n",(0,l.jsx)(n.p,{children:"Here is a more complicated example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };\n        assert!(f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };\n        assert!(f1 + f2 == 2, 42);\n    }\n}\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Fields of structs can serve double duty, identifying the field to bind ",(0,l.jsx)(n.em,{children:"and"})," the name of the\nvariable. This is sometimes referred to as punning."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let X { f } = e;\n"})}),"\n",(0,l.jsx)(n.p,{children:"is equivalent to:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let X { f: f } = e;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["As shown with tuples, you cannot declare more than one local with the same name in a single ",(0,l.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let Y { x1: x, x2: x } = e; // ERROR!\n"})}),"\n",(0,l.jsx)(n.h3,{id:"destructuring-against-references",children:"Destructuring against references"}),"\n",(0,l.jsx)(n.p,{children:"In the examples above for structs, the bound value in the let was moved, destroying the struct value\nand binding its fields."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"struct T { f1: u64, f2: u64 }\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n"})}),"\n",(0,l.jsxs)(n.p,{children:["In this scenario the struct value ",(0,l.jsx)(n.code,{children:"T { f1: 1, f2: 2 }"})," no longer exists after the ",(0,l.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For\nexample:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &t;\n// local1: &u64\n// local2: &u64\n"})}),"\n",(0,l.jsx)(n.p,{children:"And similarly with mutable references:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &mut t;\n// local1: &mut u64\n// local2: &mut u64\n"})}),"\n",(0,l.jsx)(n.p,{children:"This behavior can also work with nested structs."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n    struct X { f: u64 }\n    struct Y { x1: X, x2: X }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    fun example() {\n        let y = Y { x1: new_x(), x2: new_x() };\n\n        let Y { x1: X { f }, x2 } = &y;\n        assert!(*f + x2.f == 2, 42);\n\n        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;\n        *f1 = *f1 + 1;\n        *f2 = *f2 + 1;\n        assert!(*f1 + *f2 == 4, 42);\n    }\n}\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ignoring-values",children:"Ignoring Values"}),"\n",(0,l.jsxs)(n.p,{children:["In ",(0,l.jsx)(n.code,{children:"let"})," bindings, it is often helpful to ignore some values. Local variables that start with ",(0,l.jsx)(n.code,{children:"_"}),"\nwill be ignored and not introduce a new variable"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"fun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let (x1, _, z1) = three();\nlet (x2, _y, z2) = three();\nassert!(x1 + z1 == x2 + z2, 42);\n"})}),"\n",(0,l.jsx)(n.p,{children:"This can be necessary at times as the compiler will error on unused local variables"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let (x1, y, z1) = three(); // ERROR!\n//       ^ unused local 'y'\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"general-let-grammar",children:["General ",(0,l.jsx)(n.code,{children:"let"})," grammar"]}),"\n",(0,l.jsxs)(n.p,{children:["All the different structures in ",(0,l.jsx)(n.code,{children:"let"})," can be combined! With that we arrive at this general\ngrammar for ",(0,l.jsx)(n.code,{children:"let"})," statements:"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"let-binding"})," \u2192 ",(0,l.jsx)(n.strong,{children:"let"})," ",(0,l.jsx)(n.em,{children:"pattern-or-list"})," ",(0,l.jsx)(n.em,{children:"type-annotation"}),(0,l.jsx)("sub",{children:(0,l.jsx)(n.em,{children:"opt"})})," ",(0,l.jsx)(n.em,{children:"initializer"}),(0,l.jsx)("sub",{children:(0,l.jsx)(n.em,{children:"opt"})})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"pattern-or-list"})," \u2192 ",(0,l.jsx)(n.em,{children:"pattern"})," | ",(0,l.jsx)(n.strong,{children:"("})," ",(0,l.jsx)(n.em,{children:"pattern-list"})," ",(0,l.jsx)(n.strong,{children:")"})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"pattern-list"})," \u2192 ",(0,l.jsx)(n.em,{children:"pattern"})," ",(0,l.jsx)(n.strong,{children:","}),(0,l.jsx)("sub",{children:(0,l.jsx)(n.em,{children:"opt"})})," | ",(0,l.jsx)(n.em,{children:"pattern"})," ",(0,l.jsx)(n.strong,{children:","})," ",(0,l.jsx)(n.em,{children:"pattern-list"})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"type-annotation"})," \u2192 ",(0,l.jsx)(n.strong,{children:":"})," ",(0,l.jsx)(n.em,{children:"type"})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"initializer"})," \u2192 ",(0,l.jsx)(n.strong,{children:"="})," ",(0,l.jsx)(n.em,{children:"expression"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The general term for the item that introduces the bindings is a ",(0,l.jsx)(n.em,{children:"pattern"}),". The pattern serves to\nboth destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as\nfollows:"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"pattern"})," \u2192 ",(0,l.jsx)(n.em,{children:"local-variable"})," | ",(0,l.jsx)(n.em,{children:"struct-type"})," ",(0,l.jsx)(n.strong,{children:"{"})," ",(0,l.jsx)(n.em,{children:"field-binding-list"})," ",(0,l.jsx)(n.strong,{children:"}"})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"field-binding-list"})," \u2192 ",(0,l.jsx)(n.em,{children:"field-binding"})," ",(0,l.jsx)(n.strong,{children:","}),(0,l.jsx)("sub",{children:(0,l.jsx)(n.em,{children:"opt"})})," | ",(0,l.jsx)(n.em,{children:"field-binding"})," ",(0,l.jsx)(n.strong,{children:","})," ",(0,l.jsx)(n.em,{children:"field-binding-list"})]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"field-binding"})," \u2192 ",(0,l.jsx)(n.em,{children:"field"})," | ",(0,l.jsx)(n.em,{children:"field"})," ",(0,l.jsx)(n.strong,{children:":"})," ",(0,l.jsx)(n.em,{children:"pattern"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"A few concrete examples with this grammar applied:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"    let (x, y): (u64, u64) = (0, 1);\n//       ^                           local-variable\n//       ^                           pattern\n//          ^                        local-variable\n//          ^                        pattern\n//          ^                        pattern-list\n//       ^^^^                        pattern-list\n//      ^^^^^^                       pattern-or-list\n//            ^^^^^^^^^^^^           type-annotation\n//                         ^^^^^^^^  initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\n    let Foo { f, g: x } = Foo { f: 0, g: 1 };\n//      ^^^                                    struct-type\n//            ^                                field\n//            ^                                field-binding\n//               ^                             field\n//                  ^                          local-variable\n//                  ^                          pattern\n//               ^^^^                          field-binding\n//            ^^^^^^^                          field-binding-list\n//      ^^^^^^^^^^^^^^^                        pattern\n//      ^^^^^^^^^^^^^^^                        pattern-or-list\n//                      ^^^^^^^^^^^^^^^^^^^^   initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n"})}),"\n",(0,l.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,l.jsx)(n.h3,{id:"assignments",children:"Assignments"}),"\n",(0,l.jsxs)(n.p,{children:["After the local is introduced (either by ",(0,l.jsx)(n.code,{children:"let"})," or as a function parameter), the local can be\nmodified via an assignment:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"x = e\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Unlike ",(0,l.jsx)(n.code,{children:"let"})," bindings, assignments are expressions. In some languages, assignments return the value\nthat was assigned, but in Move, the type of any assignment is always ",(0,l.jsx)(n.code,{children:"()"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"(x = e: ())\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Practically, assignments being expressions means that they can be used without adding a new\nexpression block with braces (",(0,l.jsx)(n.code,{children:"{"}),"...",(0,l.jsx)(n.code,{children:"}"}),")."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nif (cond) x = 1 else x = 2;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The assignment uses the same pattern syntax scheme as ",(0,l.jsx)(n.code,{children:"let"})," bindings:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule example {\n    struct X { f: u64 }\n\n    fun new_x(): X {\n        X { f: 1 }\n    }\n\n    // This example will complain about unused variables and assignments.\n    fun example() {\n       let (x, _, z) = (0, 1, 3);\n       let (x, y, f, g);\n\n       (X { f }, X { f: x }) = (new_x(), new_x());\n       assert!(f + x == 2, 42);\n\n       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);\n    }\n}\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Note that a local variable can only have one type, so the type of the local cannot change between\nassignments."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x;\nx = 0;\nx = false; // ERROR!\n"})}),"\n",(0,l.jsx)(n.h3,{id:"mutating-through-a-reference",children:"Mutating through a reference"}),"\n",(0,l.jsxs)(n.p,{children:["In addition to directly modifying a local with assignment, a local can be modified via a mutable\nreference ",(0,l.jsx)(n.code,{children:"&mut"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nlet r = &mut x;\n*r = 1;\nassert!(x == 1, 42);\n"})}),"\n",(0,l.jsx)(n.p,{children:"This is particularly useful if either:"}),"\n",(0,l.jsx)(n.p,{children:"(1) You want to modify different variables depending on some condition."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nlet y = 1;\nlet r = if (cond) {\n  &mut x\n} else {\n  &mut y\n};\n*r = *r + 1;\n"})}),"\n",(0,l.jsx)(n.p,{children:"(2) You want another function to modify your local value."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nmodify_ref(&mut x);\n"})}),"\n",(0,l.jsx)(n.p,{children:"This sort of modification is how you modify structs and vectors!"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let v = vector::empty();\nvector::push_back(&mut v, 100);\nassert!(*vector::borrow(&v, 0) == 100, 42);\n"})}),"\n",(0,l.jsxs)(n.p,{children:["For more details, see ",(0,l.jsx)(n.a,{href:"/move/book/references",children:"Move references"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,l.jsxs)(n.p,{children:["Any local declared with ",(0,l.jsx)(n.code,{children:"let"})," is available for any subsequent expression, ",(0,l.jsx)(n.em,{children:"within that scope"}),".\nScopes are declared with expression blocks, ",(0,l.jsx)(n.code,{children:"{"}),"...",(0,l.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Locals cannot be used outside the declared scope."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\n{\n    let y = 1;\n};\nx + y // ERROR!\n//  ^ unbound local 'y'\n"})}),"\n",(0,l.jsxs)(n.p,{children:["But, locals from an outer scope ",(0,l.jsx)(n.em,{children:"can"})," be used in a nested scope."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"{\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Locals can be mutated in any scope where they are accessible. That mutation survives with the local,\nregardless of the scope that performed the mutation."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nx = x + 1;\nassert!(x == 1, 42);\n{\n    x = x + 1;\n    assert!(x == 2, 42);\n};\nassert!(x == 2, 42);\n"})}),"\n",(0,l.jsx)(n.h3,{id:"expression-blocks",children:"Expression Blocks"}),"\n",(0,l.jsxs)(n.p,{children:["An expression block is a series of statements separated by semicolons (",(0,l.jsx)(n.code,{children:";"}),"). The resulting value of\nan expression block is the value of the last expression in the block."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"{ let x = 1; let y = 1; x + y }\n"})}),"\n",(0,l.jsxs)(n.p,{children:["In this example, the result of the block is ",(0,l.jsx)(n.code,{children:"x + y"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["A statement can be either a ",(0,l.jsx)(n.code,{children:"let"})," declaration or an expression. Remember that assignments (",(0,l.jsx)(n.code,{children:"x = e"}),")\nare expressions of type ",(0,l.jsx)(n.code,{children:"()"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"{ let x; let y = 1; x = 1; x + y }\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Function calls are another common expression of type ",(0,l.jsx)(n.code,{children:"()"}),". Function calls that modify data are\ncommonly used as statements."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"{ let v = vector::empty(); vector::push_back(&mut v, 1); v }\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This is not just limited to ",(0,l.jsx)(n.code,{children:"()"})," types---any expression can be used as a statement in a sequence!"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'{\n    let x = 0;\n    x + 1; // value is discarded\n    x + 2; // value is discarded\n    b"hello"; // value is discarded\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["But! If the expression contains a resource (a value without the ",(0,l.jsx)(n.code,{children:"drop"})," ",(0,l.jsx)(n.a,{href:"/move/book/abilities",children:"ability"}),"),\nyou will get an error. This is because Move's type system guarantees that any value that is dropped\nhas the ",(0,l.jsx)(n.code,{children:"drop"})," ",(0,l.jsx)(n.a,{href:"/move/book/abilities",children:"ability"}),". (Ownership must be transferred or the value must be\nexplicitly destroyed within its declaring module.)"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"{\n    let x = 0;\n    Coin { value: x }; // ERROR!\n//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability\n    x\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["If a final expression is not present in a block---that is, if there is a trailing semicolon ",(0,l.jsx)(n.code,{children:";"}),",\nthere is an implicit ",(0,l.jsxs)(n.a,{href:"https://en.wikipedia.org/wiki/Unit_type",children:["unit ",(0,l.jsx)(n.code,{children:"()"})," value"]}),". Similarly, if the expression block is empty, there is an\nimplicit unit ",(0,l.jsx)(n.code,{children:"()"})," value."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"// Both are equivalent\n{ x = x + 1; 1 / x; }\n{ x = x + 1; 1 / x; () }\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"// Both are equivalent\n{ }\n{ () }\n"})}),"\n",(0,l.jsx)(n.p,{children:"An expression block is itself an expression and can be used anyplace an expression is used. (Note:\nThe body of a function is also an expression block, but the function body cannot be replaced by\nanother expression.)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'let my_vector: vector<vector<u8>> = {\n    let v = vector::empty();\n    vector::push_back(&mut v, b"hello");\n    vector::push_back(&mut v, b"goodbye");\n    v\n};\n'})}),"\n",(0,l.jsx)(n.p,{children:"(The type annotation is not needed in this example and only added for clarity.)"}),"\n",(0,l.jsx)(n.h3,{id:"shadowing",children:"Shadowing"}),"\n",(0,l.jsxs)(n.p,{children:["If a ",(0,l.jsx)(n.code,{children:"let"})," introduces a local variable with a name already in scope, that previous variable can no\nlonger be accessed for the rest of this scope. This is called ",(0,l.jsx)(n.em,{children:"shadowing"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nassert!(x == 0, 42);\n\nlet x = 1; // x is shadowed\nassert!(x == 1, 42);\n"})}),"\n",(0,l.jsx)(n.p,{children:"When a local is shadowed, it does not need to retain the same type as before."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'let x = 0;\nassert!(x == 0, 42);\n\nlet x = b"hello"; // x is shadowed\nassert!(x == b"hello", 42);\n'})}),"\n",(0,l.jsxs)(n.p,{children:["After a local is shadowed, the value stored in the local still exists, but will no longer be\naccessible. This is important to keep in mind with values of types without the\n",(0,l.jsxs)(n.a,{href:"/move/book/abilities",children:[(0,l.jsx)(n.code,{children:"drop"})," ability"]}),", as ownership of the value must be transferred by the end of the\nfunction."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"address 0x42 {\n    module example {\n        struct Coin has store { value: u64 }\n\n        fun unused_resource(): Coin {\n            let x = Coin { value: 0 }; // ERROR!\n//              ^ This local still contains a value without the `drop` ability\n            x.value = 1;\n            let x = Coin { value: 10 };\n            x\n//          ^ Invalid return\n        }\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is\ngone once that scope ends."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\n{\n    let x = 1;\n    assert!(x == 1, 42);\n};\nassert!(x == 0, 42);\n"})}),"\n",(0,l.jsx)(n.p,{children:"Remember, locals can change type when they are shadowed."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'let x = 0;\n{\n    let x = b"hello";\n    assert!(x = b"hello", 42);\n};\nassert!(x == 0, 42);\n'})}),"\n",(0,l.jsx)(n.h2,{id:"move-and-copy",children:"Move and Copy"}),"\n",(0,l.jsxs)(n.p,{children:["All local variables in Move can be used in two ways, either by ",(0,l.jsx)(n.code,{children:"move"})," or ",(0,l.jsx)(n.code,{children:"copy"}),". If one or the other\nis not specified, the Move compiler is able to infer whether a ",(0,l.jsx)(n.code,{children:"copy"})," or a ",(0,l.jsx)(n.code,{children:"move"})," should be used.\nThis means that in all the examples above, a ",(0,l.jsx)(n.code,{children:"move"})," or a ",(0,l.jsx)(n.code,{children:"copy"})," would be inserted by the\ncompiler. A local variable cannot be used without the use of ",(0,l.jsx)(n.code,{children:"move"})," or ",(0,l.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"copy"})," will likely feel the most familiar coming from other programming languages, as it creates a\nnew copy of the value inside the variable to use in that expression. With ",(0,l.jsx)(n.code,{children:"copy"}),", the local\nvariable can be used more than once."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 0;\nlet y = copy x + 1;\nlet z = copy x + 2;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Any value with the ",(0,l.jsx)(n.code,{children:"copy"})," ",(0,l.jsx)(n.a,{href:"/move/book/abilities",children:"ability"})," can be copied in this way."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"move"})," takes the value out of the local variable ",(0,l.jsx)(n.em,{children:"without"})," copying the data. After a ",(0,l.jsx)(n.code,{children:"move"})," occurs,\nthe local variable is unavailable."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"let x = 1;\nlet y = move x + 1;\n//      ------ Local was moved here\nlet z = move x + 2; // Error!\n//      ^^^^^^ Invalid usage of local 'x'\ny + z\n"})}),"\n",(0,l.jsx)(n.h3,{id:"safety",children:"Safety"}),"\n",(0,l.jsxs)(n.p,{children:["Move's type system will prevent a value from being used after it is moved. This is the same safety\ncheck described in ",(0,l.jsxs)(n.a,{href:"#let-bindings",children:[(0,l.jsx)(n.code,{children:"let"})," declaration"]})," that prevents local variables from being used\nbefore it is assigned a value."]}),"\n",(0,l.jsx)(n.h3,{id:"inference",children:"Inference"}),"\n",(0,l.jsxs)(n.p,{children:["As mentioned above, the Move compiler will infer a ",(0,l.jsx)(n.code,{children:"copy"})," or ",(0,l.jsx)(n.code,{children:"move"})," if one is not indicated. The\nalgorithm for doing so is quite simple:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Any value with the ",(0,l.jsx)(n.code,{children:"copy"})," ",(0,l.jsx)(n.a,{href:"/move/book/abilities",children:"ability"})," is given a ",(0,l.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Any reference (both mutable ",(0,l.jsx)(n.code,{children:"&mut"})," and immutable ",(0,l.jsx)(n.code,{children:"&"}),") is given a ",(0,l.jsx)(n.code,{children:"copy"}),".","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Except under special circumstances where it is made a ",(0,l.jsx)(n.code,{children:"move"})," for predictable borrow checker\nerrors."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["Any other value is given a ",(0,l.jsx)(n.code,{children:"move"}),"."]}),"\n",(0,l.jsx)(n.li,{children:"If the compiler can prove that the source value with copy ability is not used after the\nassignment, then a move may be used instead of a copy for performance, but this will be invisible\nto the programmer (except in possible decreased time or gas cost)."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'struct Foo {\n    f: u64\n}\n\nstruct Coin has copy {\n    value: u64\n}\n\nlet s = b"hello";\nlet foo = Foo { f: 0 };\nlet coin = Coin { value: 0 };\n\nlet s2 = s; // copy\nlet foo2 = foo; // move\nlet coin2 = coin; // copy\n\nlet x = 0;\nlet b = false;\nlet addr = @0x42;\nlet x_ref = &x;\nlet coin_ref = &mut coin2;\n\nlet x2 = x; // copy\nlet b2 = b; // copy\nlet addr2 = @0x42; // copy\nlet x_ref2 = x_ref; // copy\nlet coin_ref2 = coin_ref; // copy\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},83581:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>r});var l=s(11855);const a={},i=l.createContext(a);function t(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),l.createElement(i.Provider,{value:n},e.children)}}}]);