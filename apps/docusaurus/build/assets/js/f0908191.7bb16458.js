"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[9333],{8077:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=a(63159),o=a(83581);const i={},s="Package Upgrades",r={id:"move/book/package-upgrades",title:"Package Upgrades",description:"Move code (e.g., Move modules) on the Aptos blockchain can be upgraded. This",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/package-upgrades.md",sourceDirName:"move/book",slug:"/move/book/package-upgrades",permalink:"/move/book/package-upgrades",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/package-upgrades.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"Packages",permalink:"/move/book/packages"},next:{title:"Unit Tests",permalink:"/move/book/unit-testing"}},c={},d=[{value:"How it works",id:"how-it-works",level:2},{value:"How to upgrade",id:"how-to-upgrade",level:2},{value:"Upgrade policies",id:"upgrade-policies",level:2},{value:"Compatibility rules",id:"compatibility-rules",level:2},{value:"Security considerations for dependencies",id:"security-considerations-for-dependencies",level:2},{value:"Programmatic upgrade",id:"programmatic-upgrade",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"package-upgrades",children:"Package Upgrades"}),"\n",(0,t.jsx)(n.p,{children:"Move code (e.g., Move modules) on the Aptos blockchain can be upgraded. This\nallows code owners and module developers to update and evolve their contracts\nunder a single, stable, well-known account address that doesn't change. If a\nmodule upgrade happens, all consumers of that module will automatically receive\nthe latest version of the code (e.g., the next time they interact with it)."}),"\n",(0,t.jsxs)(n.p,{children:["The Aptos blockchain natively supports different ",(0,t.jsx)(n.em,{children:"upgrade policies"}),", which allow\nmove developers to explicitly define the constraints around how their move code\ncan be upgraded. The default policy is ",(0,t.jsx)(n.em,{children:"backwards compatible"}),". This means that\ncode upgrades are accepted only if they guarantee that no existing resource storage\nor public APIs are broken by the upgrade (including public functions).\nThis compatibility checking is possible because of Move's strongly typed bytecode\nsemantics."]}),"\n",(0,t.jsxs)(n.p,{children:["We note, however, that even compatible upgrades can have hazardous effects on\napplications and dependent Move code (for example, if the semantics of the underlying\nmodule are modified). As a result, developers should be careful when depending on\nthird-party Move code that can be upgraded on-chain. See\n",(0,t.jsx)(n.a,{href:"#security-considerations-for-dependencies",children:"Security considerations for dependencies"}),"\nfor more details."]}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,t.jsxs)(n.p,{children:["Move code upgrades on the Aptos blockchain happen at the ",(0,t.jsx)(n.a,{href:"/move/book/packages",children:"Move package"}),"\ngranularity. A package specifies an upgrade policy in the ",(0,t.jsx)(n.code,{children:"Move.toml"})," manifest:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "MyApp"\nversion = "0.0.1"\nupgrade_policy = "compatible"\n...\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"Compatibility check",type:"tip",children:(0,t.jsx)(n.p,{children:"Aptos checks compatibility at the time a Move package is published via an Aptos transaction. This transaction will abort if deemed incompatible."})}),"\n",(0,t.jsx)(n.h2,{id:"how-to-upgrade",children:"How to upgrade"}),"\n",(0,t.jsxs)(n.p,{children:["To upgrade already published Move code, simply attempt to republish the code at\nthe same address that it was previously published. This can be done by following the\ninstructions for code compilation and publishing using the\n",(0,t.jsx)(n.a,{href:"/tools/aptos-cli/use-cli/use-aptos-cli",children:"Aptos CLI"}),". For an example,\nsee the ",(0,t.jsx)(n.a,{href:"/tutorials/first-move-module",children:"Your First Move Module"})," tutorial."]}),"\n",(0,t.jsx)(n.h2,{id:"upgrade-policies",children:"Upgrade policies"}),"\n",(0,t.jsx)(n.p,{children:"There are two different upgrade policies currently supported by Aptos:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"compatible"}),": these upgrades must be backwards compatible, specifically:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For storage, all old struct declarations must be the same in\nthe new code. This ensures that the existing state of storage is\ncorrectly interpreted by the new code. However, new struct declarations\ncan be added."}),"\n",(0,t.jsx)(n.li,{children:"For APIs, all existing public functions must have the same signature as\nbefore. New functions, including public and entry functions, can be added."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"immutable"}),": the code is not upgradeable and is guaranteed to stay the same\nforever."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Those policies are ordered regarding strength such that ",(0,t.jsx)(n.code,{children:"compatible < immutable"}),",\ni.e., compatible is weaker than immutable. The policy of a package on-chain can\nonly get stronger, not weaker. Moreover, the policy of all dependencies of a\npackage must be stronger or equal to the policy of the given package. For example,\nan ",(0,t.jsx)(n.code,{children:"immutable"})," package cannot refer directly or indirectly to a ",(0,t.jsx)(n.code,{children:"compatible"})," package.\nThis gives users the guarantee that no unexpected updates can happen under the hood."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that there is one exception to the above rule: framework packages\ninstalled at addresses ",(0,t.jsx)(n.code,{children:"0x1"})," to ",(0,t.jsx)(n.code,{children:"0xa"})," are exempted from the dependency check.\nThis is necessary so one can define an ",(0,t.jsx)(n.code,{children:"immutable"})," package based on the standard\nlibraries, which have the ",(0,t.jsx)(n.code,{children:"compatible"})," policy to allow critical upgrades and fixes."]}),"\n",(0,t.jsx)(n.h2,{id:"compatibility-rules",children:"Compatibility rules"}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"compatible"})," upgrade policy, a module package can be upgraded. However, updates to existing modules already\npublished previously need to be compatible and follow the rules below:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All existing structs' fields cannot be updated. This means no new fields can be added and existing fields cannot be\nmodified. Struct abilities also cannot be changed (no new ones added or existing removed)."}),"\n",(0,t.jsx)(n.li,{children:"All public and entry functions cannot change their signature (argument types, type argument, return types). However,\nargument names can change."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"public(friend)"})," functions are treated as private and thus their signature can arbitrarily change. This is safe as\nonly modules in the same package can call friend functions anyway, and they need to be updated if the signature changes."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When updating your modules, if you see an incompatible error, make sure to check the above rules and fix any violations."}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations-for-dependencies",children:"Security considerations for dependencies"}),"\n",(0,t.jsx)(n.p,{children:"As mentioned above, even compatible upgrades can have disastrous effects for\napplications that depend on the upgraded code. These effects can come from bugs,\nbut they can also be the result of malicious upgrades. For example,\nan upgraded dependency can suddenly make all functions abort, breaking the\noperation of your Move code. Alternatively, an upgraded dependency can make\nall functions suddenly cost much more gas to execute then before the upgrade.\nAs result, dependencies to upgradeable packages need to be handled with care:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The safest dependency is, of course, an ",(0,t.jsx)(n.code,{children:"immutable"})," package. This guarantees\nthat the dependency will never change, including its transitive dependencies.\nIn order to update an immutable package, the owner would have to introduce a\nnew major version, which is practically like deploying a new, separate\nand independent package. This is because major versioning can be expressed\nonly by name (e.g. ",(0,t.jsx)(n.code,{children:"module feature_v1"})," and ",(0,t.jsx)(n.code,{children:"module feature_v2"}),"). However,\nnot all package owners like to publish their code as ",(0,t.jsx)(n.code,{children:"immutable"}),", because this\ntakes away the ability to fix bugs and update the code in place."]}),"\n",(0,t.jsxs)(n.li,{children:["If you have a dependency to a ",(0,t.jsx)(n.code,{children:"compatible"})," package, it is highly\nrecommended you know and understand the entity publishing the package.\nThe highest level of assurance is when the package is governed by a\nDecentralized Autonomous Organization (DAO) where no single user can initiate\nan upgrade; a vote or similar has to be taken. This is the case for the Aptos\nframework."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"programmatic-upgrade",children:"Programmatic upgrade"}),"\n",(0,t.jsxs)(n.p,{children:["In general, Aptos offers, via the Move module ",(0,t.jsx)(n.code,{children:"aptos_framework::code"}),",\nways to publish code from anywhere in your smart contracts. However,\nnotice that code published in the current transaction can be executed\nonly after that transaction ends."]}),"\n",(0,t.jsxs)(n.p,{children:["The Aptos framework itself, including all the on-chain administration logic, is\nan example for programmatic upgrade. The framework is marked as ",(0,t.jsx)(n.code,{children:"compatible"}),".\nUpgrades happen via specific generated governance scripts. For more details,\nsee ",(0,t.jsx)(n.a,{href:"/concepts/governance",children:"Aptos Governance"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},83581:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>r});var t=a(11855);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);